from django.db.models.aggregates import Count
from django.shortcuts import get_object_or_404
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.generics import ListCreateAPIView
from rest_framework import status
from rest_framework.mixins import CreateModelMixin,UpdateModelMixin, RetrieveModelMixin, DestroyModelMixin
from rest_framework import viewsets
from rest_framework.decorators import action

#class based view
from rest_framework.views import APIView

from .models import Product, Customer, Collection, Cart, CartItem, Order, OrderItem, ProductImage
from .serializers import ProductSerializer, CustomerSerializer, CollectionSerializer, CartSerializer, CartItemSerializer, AddCartItemSerializer, UpdateItemSerializer, OrderSerializer, CreateOrderSerializer, UpdateOrderSerializer, ProductImageSerializer

from rest_framework.permissions import IsAuthenticated, AllowAny, IsAdminUser, DjangoModelPermissions
from .permissions import IsAdminOrReadOnly, FullDjangoModelPermissions, ViewCustomerHistoryPermission


# Create your views here.
@api_view(['GET'])
def customer_detail(request):
    queryset =  Customer.objects.all()
    serializer = CustomerSerializer(queryset, many=True)
    return Response(serializer.data)



# generic view(mixins)
# class product_list(ListCreateAPIView):
#     permission_classes = [IsAdminOrReadOnly]
#     def get_queryset(self):
#         return Product.objects.all()
    
#     def get_serializer_class(self):
#         return ProductSerializer  # just the class
     
     
       
# # class based view 
# class product_detail(APIView): 
    
 
#     def get(self, request, id): 
#         product = Product.objects.get(pk=id) 
#         try:
#             serializers = ProductSerializer(product)
#             return Response(serializers.data)
#         except Product.DoesNotExist:
#             return Response(status=status.HTTP_404_NOT_FOUND)

#     def put(self, request, id): 
#         product = Product.objects.get(pk=id) 
#         serializer = ProductSerializer(product, data = request.data)
#         serializer.is_valid(raise_exception=True)
#         serializer.save()
#         return Response(serializer.data, status=status.HTTP_200_OK) 

#     def delete(self, request, id): 
#         product = Product.objects.get(pk=id) 
#         if product.orderitems.count() > 0:
#             return Response({"message": "Product cannot be deleted because it is associated with an order_item"},status=status.HTTP_405_METHOD_NOT_ALLOWED) 
        
#         product.delete()
#         return Response(status=status.HTTP_204_NO_CONTENT)
  
  
    
class ProductImageViewset(viewsets.ModelViewSet):
    serializer_class = ProductImageSerializer
       
    def get_serializer_context(self):
        return {'product_id': self.kwargs['product_pk'], 'request': self.request}
    
    def get_queryset(self):
        # /products/(product_pk)/images/(pk)
        # get product id from url
        return ProductImage.objects.filter(product_id = self.kwargs['product_pk'])
    
         

class ProductViewSet(viewsets.ModelViewSet):
    queryset = Product.objects.prefetch_related('images').all()
    serializer_class = ProductSerializer
    # filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    # filterset_class = ProductFilter
    # pagination_class = DefaultPagination
    permission_classes = [IsAdminOrReadOnly]
    search_fields = ['title', 'description']
    ordering_fields = ['unit_price', 'last_update']

    def get_serializer_context(self):
        return {'request': self.request}

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs['pk']).count() > 0:
            return Response({'error': 'Product cannot be deleted because it is associated with an order item.'}, status=status.HTTP_405_METHOD_NOT_ALLOWED)

        return super().destroy(request, *args, **kwargs)   
    
    
    
# generic view (mixins)

class Collection_list(ListCreateAPIView):
    permission_classes = [IsAdminOrReadOnly]
    def get_queryset(self):
        # count products using reverse relationship generated by django
        return Collection.objects.annotate(product_count = Count('products')).all()

    def get_serializer_class(self):
        return CollectionSerializer
    
    


# regular view
@api_view(['GET','PUT', 'DELETE'])
def Collection_detail(request, pk):
    
    # collection = get_object_or_404(Collection.objects.annotate(       product_count = Count('products')), pk=pk 
    # )
    
    #or
    
    try:
        collection = Collection.objects.annotate(product_count = Count('products')).get(pk=pk)
    except Collection.DoesNotExist:
        return Response({"message": "The product does not exists!!"},status=status.HTTP_404_NOT_FOUND)
    
    
    if request.method == 'GET':
        serializer = CollectionSerializer(collection)
        return Response(serializer.data)
    
    elif request.method == 'PUT':
        serializer = CollectionSerializer(collection,data = request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)
    
    elif request.method == 'DELETE':
        if collection.products.count() > 0:
            return Response(status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        collection.delete()
        return Response(status=status.HTTP_200_OK)
    


   
   
class CartViewSet(CreateModelMixin,RetrieveModelMixin,DestroyModelMixin, viewsets.GenericViewSet):
    # prefetch cart with its items and for each item pre load product
    queryset =  Cart.objects.prefetch_related('items__product').all()
    # prefetch_related  :  cart can have multiple items
    # select_related : single related object like foreign key
    serializer_class = CartSerializer
    lookup_field = 'id'
    


class CartItemViewset(viewsets.ModelViewSet):
    
    # names should be in lowercase
    http_method_names = ['get','post','patch', 'delete']
    
    def get_serializer_class(self):
         if self.request.method == 'POST':
             return AddCartItemSerializer
         elif self.request.method == 'PATCH':
             return UpdateItemSerializer
         return CartItemSerializer
     
     
    def get_serializer_context(self):
        return {'cart_id': self.kwargs['cart_id']} 
    
   
    def get_queryset(self):
        return CartItem.objects.filter(cart_id=self.kwargs['cart_id']).select_related('product')
    
    


class CustomerViewSet(viewsets.ModelViewSet):
    
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
    permission_classes = [IsAdminUser]
    
    @action(detail=False, methods=['GET', 'PUT'], permission_classes=[IsAuthenticated])
    def me(self, request):
        customer = Customer.objects.get(user_id = request.user.id)
        
        if request.method == 'GET':
            serializer = CustomerSerializer(customer)
            return Response(serializer.data)
        
        elif request.method == 'PUT':
            serializer  = CustomerSerializer(customer, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data)
    
    
    @action(detail=True, permission_classes=[ViewCustomerHistoryPermission])
    def history(self, request, pk):
        return Response('ok')
        
    
    
    
class OrderViewset(viewsets.ModelViewSet):
    http_method_names = ['get','patch','delete','head','options']
    def get_permissions(self):
        if self.request.method in ['PATCH','DELETE']:
            return [IsAdminUser()]
        return [IsAuthenticated()] 
    
    def create(self, request, *args, **kwargs):
        serializer = CreateOrderSerializer(data=request.data, context = {'user_id': self.request.user.id})
        serializer.is_valid(raise_exception=True)
        order = serializer.save()
        serializer = OrderSerializer(order)
        return Response(serializer.data)
    
    def get_serializer_class(self):
        if self.request.method == 'POST':
            return CreateOrderSerializer
        elif self.request.method == 'PATCH':
            return UpdateOrderSerializer
        return OrderSerializer
    
    
    def get_queryset(self):
        user = self.request.user
        
        if user.is_staff:
            return Order.objects.all()
        

        customer_id = Customer.objects.only('id').get(user_id=user.id)
        Order.objects.filter(customer_id = customer_id) 
    
